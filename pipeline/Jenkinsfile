pipeline{
    agent{
        node{
            label "maven"
        }
    }
    
    environment{
        APPLICATION_NAME = 'demo-php'
        DEV_PROJECT = "mydemo-php"
        BUILDCFG_NAME = "demo-php"
        GIT = "https://github.com/renatoppuccini/demo-php.git"
    }
    
    stages{
        stage('Delete all app objects'){
            steps {
                script {
                    openshift.withCluster() {
                        openshift.withProject(DEV_PROJECT) {
                            openshift.selector("all", [ app : BUILDCFG_NAME ]).delete()
                        }
                    }
                }
            }
        }

        stage('Create All Application Objects if it does exists') {
            when {
                expression {
                    openshift.withCluster() {
                        openshift.withProject(DEV_PROJECT) {
                            return !openshift.selector("bc", "${BUILDCFG_NAME}").exists();
                        }
                    }
                }
            }
           steps {
                script {
                    openshift.withCluster( "https://api.usa.puccini.redhat-demo.com:6443") {
                        openshift.withProject(DEV_PROJECT) {
                            //openshift.newBuild("--name=${BUILDCFG_NAME}", "--image-stream=openshift/php:latest", GIT).logs("-f")
			        openshift.selector("all", [ app : BUILDCFG_NAME ]).delete()
			        openshift.selector("all", [ is : BUILDCFG_NAME ]).delete()
				
				echo "Using project: ${openshift.project()}"
				
				def bc = openshift.newApp("--name=${BUILDCFG_NAME}", "--image-stream=openshift/php:latest", GIT).narrow('bc')
				def builds = bc.related('builds')
				echo "Waiting for build to finish"
				bc.logs("-f")
				
				builds.untilEach(1) { // We want a minimum of 1 build
				    // Unlike watch(), untilEach binds 'it' to a Selector for a single object.
				    // Thus, untilEach will only terminate when all selected objects satisfy this
				    // the condition established in the closure body (or until the timeout(10)
				    // interrupts the operation).
				    return it.object().status.phase == "Complete"
				}
				echo "Build finished"

				echo "Waiting for Deployment to finish"
				
				// Wait for application to be deployed
				  def dc = openshift.selector("dc", BUILDCFG_NAME).object()
				  def dc_version = dc.status.latestVersion
				  def rc = openshift.selector("rc", "${BUILDCFG_NAME}-${dc_version}").object()
				  dc.rollout().status()
				
				  echo "Waiting for ReplicationController ${BUILDCFG_NAME}-${dc_version} to be ready"
				  while (rc.spec.replicas != rc.status.readyReplicas) {
				    sleep 5
				    rc = openshift.selector("rc", "${BUILDCFG_NAME}-${dc_version}").object()
          			  }
				echo "Deployment ${BUILDCFG_NAME}-${dc_version} ready"
				 
                        }
                    }
                }
            }
        }
     
	   // Deploy the built image to the Development Environment.
    stage('Deploy to Dev') {
    	steps {
        	script {
		  openshift.withCluster() {
			  openshift.withProject(DEV_PROJECT) {
				// Deploy the development application.
           			//openshift.selector("dc", BUILDCFG_NAME).rollout().latest();
				  // Deploy the development application.
				 // openshift.selector("dc", "demo-php").rollout().latest();

				  
        		  }
     		 }
           }
         }
       }
	    
	
	    
	    
    }

   
    
}
